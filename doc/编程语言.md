# 编程语言

[TOC]

## C++

std::cin取消同步

```c++
std::cin.sync_with_stdio(false);
std::cin.tie(nullptr);
```

浮点数比较 可以取EPSILON = 1e-6

快读

```c++
template<typename T>
T read_integer() {
    T x = 0, f = 1;
    int ch = getchar();
    while (ch < '0' || ch > '9') {
        if (ch == '-') f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = (x << 1) + (x << 3) + (ch ^ 48);
        ch = getchar();
    }
    return x * f;
}
```

### std::sort

```c++
#include <algorithm>
#include <vector>
#include <cstdio>

struct Key {
    int x;
    int y;
};

int main() {
    std::vector<Key> keys{{100, 3}, {200, 1}, {300, 1}};
    std::sort(keys.begin(), keys.end(), [](const Key &a, const Key &b) {
        // returns true if the first argument is less than (i.e. is ordered before) the second.
        return a.y < b.y;
    });
    printf("Vector:\n");
    for (const auto &key : keys) {
        printf("x: %d, y: %d\n", key.x, key.y);
    }

    Key keys2[3] = {{100, 3}, {200, 1}, {300, 1}};
    std::sort(keys2, keys2 + 3, [](const Key &a, const Key &b) {
        return a.y < b.y;
    });
    printf("Array:\n");
    for (const auto &key : keys) {
        printf("x: %d, y: %d\n", key.x, key.y);
    }
}
```

### std::list （双向链表）

注意iterator类型声明方法。

```c++
#include <iterator>
#include <list>
#include <cstdio>
#include <unordered_map>

int main() {
  std::list<int> l;
  std::unordered_map<int, std::list<int>::iterator> front_m, back_m;
  std::unordered_map<int, std::list<int>::reverse_iterator> front_rm, back_rm;
  for (int i = 0; i < 4; ++i) {
    l.push_back(i);
    back_m[i] = std::prev(l.end());
    back_rm[i] = l.rbegin();
  }
  printf("std::prev(l.end()), l.rbegin(). l.rbegin() is dummy node\n");
  for (int i = 0; i < 4; ++i) {
    printf("%d %d\n", *back_m[i], *back_rm[i]);
  }

  l.clear();
  for (int i = 0; i < 4; ++i) {
    l.push_front(i);
    front_m[i] = l.begin();
    front_rm[i] = std::prev(l.rend());
  }
  printf("l.begin(), std::prev(l.rend())\n");
  for (int i = 0; i < 4; ++i) {
    printf("%d %d\n", *front_m[i], *front_rm[i]);
  }

  printf("erase 1\n");
  l.erase(front_m[1]);
  for (auto e : l) {
    printf("%d ", e);
  }
  return 0;
}
```

Output:
```text
std::prev(l.end()), l.rbegin(). l.rbegin() is dummy node
0 3
1 3
2 3
3 3
l.begin(), std::prev(l.rend())
0 0
1 1
2 2
3 3
erase 1
3 2 0
```

## Java

快读

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

class FastReader {
    BufferedReader br;
    StringTokenizer st;

    public FastReader() {
        br = new BufferedReader(new InputStreamReader(System.in));
    }

    String next() {
        while (st == null || !st.hasMoreElements()) {
            try {
                st = new StringTokenizer(br.readLine());
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return st.nextToken();
    }

    int nextInt() {
        return Integer.parseInt(next());
    }

    long nextLong() {
        return Long.parseLong(next());
    }

    double nextDouble() {
        return Double.parseDouble(next());
    }

    String nextLine() {
        String str = "";
        try {
            str = br.readLine();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return str;
    }
}
```
