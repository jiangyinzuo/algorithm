# 动态规划

[TOC]

## 背包问题

### 二维背包

leetcode 879 盈利计划

集团里有 n 名员工，他们可以完成各种各样的工作创造利润。

第 i 种工作会产生 profit[i] 的利润，它要求 group[i] 名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。

工作的任何至少产生 minProfit 利润的子集称为盈利计划。并且工作的成员总数最多为 n 。

有多少种计划可以选择？因为答案很大，所以 返回结果模 10^9 + 7 的值。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/profitable-schemes

```python
#利润背包，可以溢出
for p in ps: 
    for i in range(P+p, p-1, -1):
        dp[min(i,P)] += dp[i-n]
#人员背包，不能溢出
for g in gs: 
    for i in range(G, g-1, -1):
        dp[i] += dp[i-n]

# 二维背包
for p, g in zip(profit, group):
    for i in range(P+p, p-1, -1): 
        for j in range(G , g-1, -1):
            # 利润超过P的也放在 dp[P] 里 方便最后的统计
            dp[min(P,i)][j] += dp[i-p][j-g]

# 题解
class Solution:
    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:
        # dp[P][G] 达到P利润，需要的人数G 的方法数
        dp = [[0] * (N + 1)  for _ in range(P + 1)]
        dp[0][0] = 1
        for p, g in zip(profit, group):
            for i in range(P+p, p-1, -1):
                for j in range(G , g-1, -1):
                    dp[min(P,i)][j] += dp[i-p][j-g]
        return sum(dp[P]) % (10 ** 9 + 7)

```



```cpp
class Solution {
public:
	int profitableSchemes(int n, int minProfit, vector<int> &group, vector<int> &profit) {
		vector<vector<long long>> dp(minProfit + 1, vector<long long>(n + 1, 0));
		dp[0][0] = 1;
		for (int i = 0; i < group.size(); ++i) {
            // 二维背包 两重for循环可以交换位置
			for (int j = n; j >= group[i]; --j) {
				for (int k = minProfit + profit[i]; k >= profit[i]; --k) {
					dp[std::min(k, minProfit)][j] += dp[k - profit[i]][j - group[i]];
				}
			}
		}
		long long ans = 0;
		for (int i = 0; i <= n; ++i) {
			ans = (ans + dp[minProfit][i]) % 1000000007;
		}
		return (int)ans;
	}
};

```



## 最长递增子序列

```c++
// 严格递增
#include <cstdio>
#include <algorithm>

const int MAX_N = 200000;
int arr[MAX_N] = {0};

int main() {
    int n;
    scanf("%d", &n);
    
    int element, idx = 0;
    int *index;
    for (int i = 0; i < n; ++i) {
        scanf("%d", &element);
        if ((index = std::lower_bound(arr, arr + idx, element)) == arr + idx) idx++;
        *index = element;
    }
    printf("%d\n", idx);
    for (int i = 0; i < idx; ++i) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    return 0;
}
```

```c++
// 单调递增
std::vector<int> get_lcs(const std::vector<int> &vec) {
    std::vector<int> lcs;
    decltype(lcs.begin()) place;
    for (auto &e : vec) {
        if ((place = std::upper_bound(lcs.begin(), lcs.end(), e)) == lcs.end())
            lcs.push_back(e);
        else
            *place = e;
    }
    return lcs;
}
```

##### 求逆序对的个数

相当于原序列长度-最长递增子序列长度

## 树形DP

Leetcode [834. 树中距离之和](https://leetcode-cn.com/problems/sum-of-distances-in-tree/)

第一次dfs求所有子树的高度以及根节点到其它节点距离之和。

第二次dfs开始换根，求根节点到其它节点距离之和。

```c++
class Solution {
public:
    vector<vector<int>> tree;
    vector<int> sub_tree_size;
    vector<int> distance_sum;
    vector<int> ans;
    void build_tree(int N, vector<vector<int>> &edges) {
        tree.resize(N);
        for (auto &e : edges) {
            tree[e[0]].push_back(e[1]);
            tree[e[1]].push_back(e[0]);
        }
    }
    vector<int> sumOfDistancesInTree(int N, vector<vector<int>> &edges) {
        if (N == 1) return {0};
        build_tree(N, edges);
        sub_tree_size.resize(N);
        ans.resize(N);
        distance_sum.resize(N);
        dfs(0, -1);
        dfs2(0, -1);
        return ans;
    }

    void dfs(int cur_node, int father) {
        sub_tree_size[cur_node] = 1;
        distance_sum[cur_node] = 0;
        for (auto &child : tree[cur_node]) {
            if (child != father) {
                dfs(child, cur_node);
                sub_tree_size[cur_node] += sub_tree_size[child];
                distance_sum[cur_node] += distance_sum[child] + sub_tree_size[child];
            }
        }
    }

    void dfs2(int cur_node, int father) {
        if (father != -1) {
            ans[cur_node] = ans[father] + sub_tree_size[0] - 2 * sub_tree_size[cur_node];
        } else {
            ans[cur_node] = distance_sum[cur_node];
        }
        for (auto &child : tree[cur_node]) {
            if (child != father) {
                dfs2(child, cur_node);
            }
        }
    }
};

```

### 鸡蛋掉落

https://leetcode-cn.com/problems/super-egg-drop/

K个鸡蛋，N层楼，求最坏情况丢几次鸡蛋，就能确定鸡蛋最低摔碎的位置。

设$$dp[t][k]$$表示操作t次，k个鸡蛋，最多能确定几层楼。$$dp[1][k]=1, dp[t][1]=t,\\ dp[t][k] = 1 + dp[t-1][k]+dp[t-1][k-1]$$

第一次丢鸡蛋在$$dp[t-1][k-1]$$楼，如果碎了，后面t-1次操作，k-1个鸡蛋能确定位置；如果没碎，往上还能确定$$dp[t-1][k]$$层楼

```c++
class Solution {
public:
    int superEggDrop(int k, int n) {
        if (k == 1 || n == 1) return n;
        std::vector<std::vector<int>> dp(n+1, std::vector<int>(k+1));
        for (int _k = 1; _k <= k; ++_k)
            dp[1][_k] = 1;
        for (int t = 1; t <= n; ++t)
            dp[t][1] = t;
        for (int t = 2; t <= n; ++t) {
            for (int _k = 2; _k <= k; ++_k) {
                dp[t][_k] = 1 + dp[t-1][_k] + dp[t-1][_k-1];
                if (dp[t][_k] >= n) {
                    return t;
                }
            }
        }
        return -1;
    }
};
```

## 区间DP

https://codeforces.com/problemset/problem/1509/C

给n个数$$a_1,a_2,…,a_n$$，记$$d_i=max(a_1,a_2,…,a_i)−min(a_1,a_2,…,a_i).$$对它们排序，使得 $$d_1+d_2+⋯+d_n$$最小

```python
# -*- coding: utf-8 -*-

n = int(input())
arr = sorted(map(int, input().split()))

dp = [[0] * n for _ in range(n)]

for i in reversed(range(n)):
    for j in range(i + 1, n):
        dp[i][j] = arr[j] - arr[i] + min(dp[i + 1][j], dp[i][j - 1])

print(dp[0][-1])

```

